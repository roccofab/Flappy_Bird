/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */

/**
 *
 * @author roccofab
 */
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.*;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.Timer;

public class FlappyBird extends javax.swing.JPanel implements ActionListener, KeyListener{
    
    Image backgroundImg;
    Image birdImg;
    Image bottomPipeImg;
    Image topPipeImg;
    Bird bird;
    
    int velocityY = 0;  //bird move up(-y) and down(+y)
    int velocityX = -6; //move pipes to the left side(-x)
    int gravity = 1;
    
    Timer frameTimer;  //timer for drawing frames
    Timer pipeTimer;   //timer for drawing pipes
    ArrayList<Pipe> pipes;   //list of pipes
    Random random = new Random(); //random object for pipes location
    
    boolean gameOver = false;  //gameOver becomes true when the bird falls to the bottom of the screen or when it collides with one of the pipes

    /**
     * Creates new form FlappyBird
     */
    public FlappyBird() {
        initComponents();
          
        addKeyListener(this);
        backgroundImg = new ImageIcon(getClass().getResource("/resources/4622710.png")).getImage();  //initialization of the Image object backgroundImg
        birdImg = new ImageIcon(getClass().getResource("/resources/flappybird.png")).getImage();  //initialization of the Image object birdImg
        bottomPipeImg = new ImageIcon(getClass().getResource("/resources/bottompipe.png")).getImage();  //initialization of the Image object bottomPipeImg
        topPipeImg = new ImageIcon(getClass().getResource("/resources/toppipe.png")).getImage();  //initialization of the Image object topPipeImg
        bird = new Bird(birdImg);  //birdImg will be initialized with dimensions defined into the class Bird
        
        pipes = new ArrayList<Pipe>();  //initialize list of pipes
        pipeTimer = new Timer(1500, new ActionListener(){  //insert a new pipe to the frame every 1500 milliseconds
            @Override
            public void actionPerformed(ActionEvent e){
                insertPipes();
            }
        });
        pipeTimer.start();
        
        //Call the method repaint() defined into the ActionPerformed for 60 times to second this allows the game panel to be continuously updated
        frameTimer = new Timer(1000/60, this);   
        frameTimer.start();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(51, 153, 255));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1024, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 768, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /*
    This method is automatically called from the system
    super.paintChildren(g)`ensures that the panel's child components are drawn correctly
    draw(g)` draws custom elements on the panel
    */
    public void paintComponent(Graphics g){
        super.paintChildren(g);
        draw(g);
    }
    /*Draws the background image based to the panel dimensions
      Draws the bird Image based to the dimensions defined into the class Bird
    */
    public void draw(Graphics g){
        g.drawImage(backgroundImg, 0, 0, 1024,768, null);  //draw background panel
        
        g.drawImage(birdImg, bird.birdX, bird.birdY, bird.birdwidth, bird.birdheight, null);   //draw bird 
        
        //draw the pipe
        for(int i = 0; i < pipes.size(); i++){
            Pipe pipe = pipes.get(i);
            g.drawImage(pipe.pipeImg, pipe.pipeX, pipe.pipeY, pipe.pipeWidth,pipe.pipeHeight,null);
        }
    }
    public void move(){
        velocityY += gravity;  //simulates the fall by increasing velocityY with the gravity value 
        bird.birdY += velocityY;  //the bird's position is updated for each frame
        bird.birdY = Math.max(bird.birdY, 0);  //bird's range movement is top and down so the bird cannot go beyond the sky
        
        //move pipe
        for(int i = 0; i < pipes.size(); i++){
            Pipe pipe = pipes.get(i);
            pipe.pipeX += velocityX;  //pipe move to the left side at speed -6
        }
        if (bird.birdY > 768){
            gameOver = true;
        }
    }
    public void insertPipes(){
        /*
        Create an object topPipe and add it to the list of pipes.
        Create an object bottomPipe and add it to the list of pipes.
        
        Position of top pipe is based on the subtraction between starting position of pipeY and 128(pipeHeight/4) and a random number between 0 and 256:
            topPipe.pipeY - topPipe.pipeHeight - Math.random()*(topPipe.pipeHeight/2)   (starting position of pipeY is 0 and pipeHeight/4 = 128)
        
        Bottom pipes are located below every top pipe with a gap of 150
        
        */
       Pipe topPipe = new Pipe(topPipeImg); 
       Pipe bottomPipe = new Pipe(bottomPipeImg);
       
       int gap = 150;
       int randomTopPipe =(int) (topPipe.pipeY - topPipe.pipeHeight/4 - Math.random()*(topPipe.pipeHeight/2));  //random location for top pipe
       int randomBottomPipe = randomTopPipe + topPipe.pipeHeight + gap;  //position bottom pipe below top pipe with a gap
       topPipe.pipeY = randomTopPipe;
       bottomPipe.pipeY = randomBottomPipe;
       
       topPipe.pipeY = randomTopPipe;
       bottomPipe.pipeY = randomBottomPipe;
       pipes.add(topPipe);
       pipes.add(bottomPipe);
        
    }
    /*
    This method is called every frame of the milliseconds by timer
    In each frame the move method is called and the page is redrawn
    */
    @Override
    public void actionPerformed(ActionEvent e) {
        move();
        repaint();  //method repaint() call the method paintComponent() to draw the background and the bird
        
        //check for collision
        for (Pipe pipe : pipes) {
            if (collidePipe(bird, pipe)) {
                gameOver = true;
                break;
            }
        }
        if(gameOver){
            pipeTimer.stop();  //stop adding pipes to the ArrayList if gameOver = true
            frameTimer.stop();  //stop repainting and update the frame if gameOver = true
            showGameOverDialog();  //show disclaimer
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if(e.getKeyCode() == KeyEvent.VK_SPACE){  //The function is called when the space button is typed
            velocityY = -9;  //decrease velocityY when the space button is typed 
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }
    
    public boolean collidePipe(Bird bird, Pipe pipe){
        /*
        Calculate bird limits borders: the bird can be seen as a rectangle having left border limit(birdY),right border limit(birdX),
           top border limit(birdHeight) and bottom border limit(birdWidth).
        
        Calculate pipe limits border: the pipe can be seen as a rectangle having left border limit(pipeY), right border limit(pipeX),
            top border limit(pipeHeight) and bottom border limit(pipeWidth)
        
        Check for collision between bird rectangle and pipe rectangle:
              if the right border of the bird is on the left border of the pipe return true,
              if the left border of the bird is on the right border of the pipe return true,
              if the top border of the bird is on the bottom border of the pipe return true
              if the bottom border of the bird is on the top border of the pipe return true.
        */
        int birdLeft = bird.birdX;
        int birdRight = bird.birdX + bird.birdwidth;
        int birdTop = bird.birdY;
        int birdBottom = bird.birdY + bird.birdheight;
        int pipeLeft = pipe.pipeX;
        int pipeRight = pipe.pipeX + pipe.pipeWidth;
        int pipeTop = pipe.pipeY;
        int pipeBottom = pipe.pipeY + pipe.pipeHeight;
        
        if (birdRight > pipeLeft && birdLeft < pipeRight && birdBottom > pipeTop && birdTop < pipeBottom) 
            return true; 
    return false;
    }
    private void restartGame() {
        gameOver = false;
        pipes.clear();
        bird.birdX = 100;
        bird.birdY = 384;
        velocityY = 0;
        pipeTimer.start();
        frameTimer.start();
    }
    private void showGameOverDialog() {
        String[] options = {"Restart", "Exit"};
        int choice = JOptionPane.showOptionDialog(this,
                "Game Over!",
                "Game Over",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null,
                options,
                options[0]);

        if (choice == JOptionPane.YES_OPTION) {
            restartGame(); 
        } else {
            System.exit(0); 
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
